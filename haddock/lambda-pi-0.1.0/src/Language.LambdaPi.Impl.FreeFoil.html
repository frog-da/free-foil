<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DataKinds         #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE DeriveTraversable #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE GADTs             #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase        #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE PatternSynonyms   #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskell   #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE TypeOperators     #-}</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- | Free foil implementation of the \(\lambda\Pi\)-calculus (with pairs).</span><span>
</span><span id="line-10"></span><span class="hs-comment">--</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- Free foil provides __general__ definitions or implementations for the following:</span><span>
</span><span id="line-12"></span><span class="hs-comment">--</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- 1. Freely generated (from a simple signature) scope-safe AST.</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- 2. Correct capture-avoiding substitution (see 'substitute').</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- 3. Correct \(\alpha\)-equivalence checks (see 'alphaEquiv' and 'alphaEquivRefreshed') as well as \(\alpha\)-normalization (see 'refreshAST').</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- 4. Conversion helpers (see 'convertToAST' and 'convertFromAST').</span><span>
</span><span id="line-17"></span><span class="hs-comment">--</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- The following is implemented __manually__ in this module:</span><span>
</span><span id="line-19"></span><span class="hs-comment">--</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- 1. Convenient pattern synonyms.</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- 2. 'ZipMatch' instances (enabling general \(\alpha\)-equivalence).</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- 3. Conversion between scope-safe and raw term representation (the latter is generated via BNFC), see 'toLambdaPi' and 'fromLambdaPi'.</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- 4. Computation of weak head normal form (WHNF), see 'whnf'.</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- 5. Entry point, gluing everything together. See 'defaultMain'.</span><span>
</span><span id="line-25"></span><span class="hs-comment">--</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- __Note:__ free foil does not (easily) support patterns at the moment,</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- so only wildcard patterns and variable patterns are handled in this implementation.</span><span>
</span><span id="line-28"></span><span class="hs-comment">--</span><span>
</span><span id="line-29"></span><span class="hs-comment">-- See &quot;Language.LambdaPi.Impl.FreeFoilTH&quot; for a variation of this with more automation via Template Haskell.</span><span>
</span><span id="line-30"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.LambdaPi.Impl.FreeFoil</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Foil</span></span><span>              </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Foil</span></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.Free.Foil</span></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Bifunctor.Sum</span></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Bifunctor.TH</span></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span>                        </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Map</span></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span>                        </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.String</span></span><span>                     </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">IsString</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html"><span class="hs-identifier">Language.LambdaPi.Syntax.Abs</span></a></span><span>    </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Layout.html"><span class="hs-identifier">Language.LambdaPi.Syntax.Layout</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Lex.html"><span class="hs-identifier">Language.LambdaPi.Syntax.Lex</span></a></span><span>    </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Par.html"><span class="hs-identifier">Language.LambdaPi.Syntax.Par</span></a></span><span>    </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Print.html"><span class="hs-identifier">Language.LambdaPi.Syntax.Print</span></a></span><span>  </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">System.Exit</span></span><span>                     </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">exitFailure</span></span><span class="hs-special">)</span><span>
</span><span id="line-45"></span><span>
</span><span id="line-46"></span><span class="hs-comment">-- $setup</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- &gt;&gt;&gt; import qualified Control.Monad.Foil as Foil</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- &gt;&gt;&gt; import Control.Monad.Free.Foil</span><span>
</span><span id="line-49"></span><span class="hs-comment">-- &gt;&gt;&gt; :set -XOverloadedStrings</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- &gt;&gt;&gt; :set -XDataKinds</span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="annot"><span class="hs-comment">-- | The signature 'Bifunctor' for the \(\lambda\Pi\).</span></span><span>
</span><span id="line-53"></span><span class="hs-keyword">data</span><span> </span><span id="LambdaPiF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPiF"><span class="hs-identifier hs-var">LambdaPiF</span></a></span></span><span> </span><span id="local-6989586621679245581"><span class="annot"><a href="#local-6989586621679245581"><span class="hs-identifier hs-type">scope</span></a></span></span><span> </span><span id="local-6989586621679245582"><span class="annot"><a href="#local-6989586621679245582"><span class="hs-identifier hs-type">term</span></a></span></span><span>
</span><span id="line-54"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="AppF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#AppF"><span class="hs-identifier hs-var">AppF</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679245582"><span class="hs-identifier hs-type">term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245582"><span class="hs-identifier hs-type">term</span></a></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Application: \((t_1 \; t_2)\)</span></span><span>
</span><span id="line-55"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LamF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LamF"><span class="hs-identifier hs-var">LamF</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679245581"><span class="hs-identifier hs-type">scope</span></a></span><span>            </span><span class="annot"><span class="hs-comment">-- ^ Abstraction: \(\lambda x. t\)</span></span><span>
</span><span id="line-56"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PiF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PiF"><span class="hs-identifier hs-var">PiF</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679245582"><span class="hs-identifier hs-type">term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245581"><span class="hs-identifier hs-type">scope</span></a></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Dependent function type: \(\prod_{x : T_1} T_2\)</span></span><span>
</span><span id="line-57"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UniverseF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#UniverseF"><span class="hs-identifier hs-var">UniverseF</span></a></span></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ Universe (type of types): \(\mathcal{U}\)</span></span><span>
</span><span id="line-58"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679245892"><span id="local-6989586621679245899"><span class="annot"><span class="annottext">LambdaPiF scope term -&gt; LambdaPiF scope term -&gt; Bool
(LambdaPiF scope term -&gt; LambdaPiF scope term -&gt; Bool)
-&gt; (LambdaPiF scope term -&gt; LambdaPiF scope term -&gt; Bool)
-&gt; Eq (LambdaPiF scope term)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall scope term.
(Eq term, Eq scope) =&gt;
LambdaPiF scope term -&gt; LambdaPiF scope term -&gt; Bool
$c== :: forall scope term.
(Eq term, Eq scope) =&gt;
LambdaPiF scope term -&gt; LambdaPiF scope term -&gt; Bool
== :: LambdaPiF scope term -&gt; LambdaPiF scope term -&gt; Bool
$c/= :: forall scope term.
(Eq term, Eq scope) =&gt;
LambdaPiF scope term -&gt; LambdaPiF scope term -&gt; Bool
/= :: LambdaPiF scope term -&gt; LambdaPiF scope term -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679245906"><span id="local-6989586621679245917"><span id="local-6989586621679245921"><span class="annot"><span class="annottext">Int -&gt; LambdaPiF scope term -&gt; ShowS
[LambdaPiF scope term] -&gt; ShowS
LambdaPiF scope term -&gt; String
(Int -&gt; LambdaPiF scope term -&gt; ShowS)
-&gt; (LambdaPiF scope term -&gt; String)
-&gt; ([LambdaPiF scope term] -&gt; ShowS)
-&gt; Show (LambdaPiF scope term)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall scope term.
(Show term, Show scope) =&gt;
Int -&gt; LambdaPiF scope term -&gt; ShowS
forall scope term.
(Show term, Show scope) =&gt;
[LambdaPiF scope term] -&gt; ShowS
forall scope term.
(Show term, Show scope) =&gt;
LambdaPiF scope term -&gt; String
$cshowsPrec :: forall scope term.
(Show term, Show scope) =&gt;
Int -&gt; LambdaPiF scope term -&gt; ShowS
showsPrec :: Int -&gt; LambdaPiF scope term -&gt; ShowS
$cshow :: forall scope term.
(Show term, Show scope) =&gt;
LambdaPiF scope term -&gt; String
show :: LambdaPiF scope term -&gt; String
$cshowList :: forall scope term.
(Show term, Show scope) =&gt;
[LambdaPiF scope term] -&gt; ShowS
showList :: [LambdaPiF scope term] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679245925"><span id="local-6989586621679245927"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; LambdaPiF scope a -&gt; LambdaPiF scope b)
-&gt; (forall a b. a -&gt; LambdaPiF scope b -&gt; LambdaPiF scope a)
-&gt; Functor (LambdaPiF scope)
forall a b. a -&gt; LambdaPiF scope b -&gt; LambdaPiF scope a
forall a b. (a -&gt; b) -&gt; LambdaPiF scope a -&gt; LambdaPiF scope b
forall scope a b. a -&gt; LambdaPiF scope b -&gt; LambdaPiF scope a
forall scope a b.
(a -&gt; b) -&gt; LambdaPiF scope a -&gt; LambdaPiF scope b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall scope a b.
(a -&gt; b) -&gt; LambdaPiF scope a -&gt; LambdaPiF scope b
fmap :: forall a b. (a -&gt; b) -&gt; LambdaPiF scope a -&gt; LambdaPiF scope b
$c&lt;$ :: forall scope a b. a -&gt; LambdaPiF scope b -&gt; LambdaPiF scope a
&lt;$ :: forall a b. a -&gt; LambdaPiF scope b -&gt; LambdaPiF scope a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679245931"><span id="local-6989586621679245937"><span id="local-6989586621679245943"><span id="local-6989586621679245948"><span id="local-6989586621679245950"><span id="local-6989586621679245953"><span id="local-6989586621679245956"><span id="local-6989586621679245959"><span id="local-6989586621679245962"><span id="local-6989586621679245965"><span id="local-6989586621679245968"><span id="local-6989586621679245970"><span id="local-6989586621679245973"><span id="local-6989586621679245978"><span id="local-6989586621679245983"><span id="local-6989586621679245988"><span id="local-6989586621679245993"><span class="annot"><span class="annottext">(forall m. Monoid m =&gt; LambdaPiF scope m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; LambdaPiF scope a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; LambdaPiF scope a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; LambdaPiF scope a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; LambdaPiF scope a -&gt; a)
-&gt; (forall a. LambdaPiF scope a -&gt; [a])
-&gt; (forall a. LambdaPiF scope a -&gt; Bool)
-&gt; (forall a. LambdaPiF scope a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; LambdaPiF scope a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; LambdaPiF scope a -&gt; a)
-&gt; (forall a. Ord a =&gt; LambdaPiF scope a -&gt; a)
-&gt; (forall a. Num a =&gt; LambdaPiF scope a -&gt; a)
-&gt; (forall a. Num a =&gt; LambdaPiF scope a -&gt; a)
-&gt; Foldable (LambdaPiF scope)
forall a. Eq a =&gt; a -&gt; LambdaPiF scope a -&gt; Bool
forall a. Num a =&gt; LambdaPiF scope a -&gt; a
forall a. Ord a =&gt; LambdaPiF scope a -&gt; a
forall m. Monoid m =&gt; LambdaPiF scope m -&gt; m
forall a. LambdaPiF scope a -&gt; Bool
forall a. LambdaPiF scope a -&gt; Int
forall a. LambdaPiF scope a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; LambdaPiF scope a -&gt; a
forall scope a. Eq a =&gt; a -&gt; LambdaPiF scope a -&gt; Bool
forall scope a. Num a =&gt; LambdaPiF scope a -&gt; a
forall scope a. Ord a =&gt; LambdaPiF scope a -&gt; a
forall scope m. Monoid m =&gt; LambdaPiF scope m -&gt; m
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; LambdaPiF scope a -&gt; m
forall scope a. LambdaPiF scope a -&gt; Bool
forall scope a. LambdaPiF scope a -&gt; Int
forall scope a. LambdaPiF scope a -&gt; [a]
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
forall scope a. (a -&gt; a -&gt; a) -&gt; LambdaPiF scope a -&gt; a
forall scope m a. Monoid m =&gt; (a -&gt; m) -&gt; LambdaPiF scope a -&gt; m
forall scope b a. (b -&gt; a -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
forall scope a b. (a -&gt; b -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
$cfold :: forall scope m. Monoid m =&gt; LambdaPiF scope m -&gt; m
fold :: forall m. Monoid m =&gt; LambdaPiF scope m -&gt; m
$cfoldMap :: forall scope m a. Monoid m =&gt; (a -&gt; m) -&gt; LambdaPiF scope a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; LambdaPiF scope a -&gt; m
$cfoldMap' :: forall scope m a. Monoid m =&gt; (a -&gt; m) -&gt; LambdaPiF scope a -&gt; m
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; LambdaPiF scope a -&gt; m
$cfoldr :: forall scope a b. (a -&gt; b -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
$cfoldr' :: forall scope a b. (a -&gt; b -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
$cfoldl :: forall scope b a. (b -&gt; a -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
$cfoldl' :: forall scope b a. (b -&gt; a -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; LambdaPiF scope a -&gt; b
$cfoldr1 :: forall scope a. (a -&gt; a -&gt; a) -&gt; LambdaPiF scope a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; LambdaPiF scope a -&gt; a
$cfoldl1 :: forall scope a. (a -&gt; a -&gt; a) -&gt; LambdaPiF scope a -&gt; a
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; LambdaPiF scope a -&gt; a
$ctoList :: forall scope a. LambdaPiF scope a -&gt; [a]
toList :: forall a. LambdaPiF scope a -&gt; [a]
$cnull :: forall scope a. LambdaPiF scope a -&gt; Bool
null :: forall a. LambdaPiF scope a -&gt; Bool
$clength :: forall scope a. LambdaPiF scope a -&gt; Int
length :: forall a. LambdaPiF scope a -&gt; Int
$celem :: forall scope a. Eq a =&gt; a -&gt; LambdaPiF scope a -&gt; Bool
elem :: forall a. Eq a =&gt; a -&gt; LambdaPiF scope a -&gt; Bool
$cmaximum :: forall scope a. Ord a =&gt; LambdaPiF scope a -&gt; a
maximum :: forall a. Ord a =&gt; LambdaPiF scope a -&gt; a
$cminimum :: forall scope a. Ord a =&gt; LambdaPiF scope a -&gt; a
minimum :: forall a. Ord a =&gt; LambdaPiF scope a -&gt; a
$csum :: forall scope a. Num a =&gt; LambdaPiF scope a -&gt; a
sum :: forall a. Num a =&gt; LambdaPiF scope a -&gt; a
$cproduct :: forall scope a. Num a =&gt; LambdaPiF scope a -&gt; a
product :: forall a. Num a =&gt; LambdaPiF scope a -&gt; a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246003"><span id="local-6989586621679246011"><span id="local-6989586621679246017"><span id="local-6989586621679246022"><span class="annot"><span class="annottext">Functor (LambdaPiF scope)
Foldable (LambdaPiF scope)
(Functor (LambdaPiF scope), Foldable (LambdaPiF scope)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; LambdaPiF scope a -&gt; f (LambdaPiF scope b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    LambdaPiF scope (f a) -&gt; f (LambdaPiF scope a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; LambdaPiF scope a -&gt; m (LambdaPiF scope b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    LambdaPiF scope (m a) -&gt; m (LambdaPiF scope a))
-&gt; Traversable (LambdaPiF scope)
forall scope. Functor (LambdaPiF scope)
forall scope. Foldable (LambdaPiF scope)
forall scope (m :: * -&gt; *) a.
Monad m =&gt;
LambdaPiF scope (m a) -&gt; m (LambdaPiF scope a)
forall scope (f :: * -&gt; *) a.
Applicative f =&gt;
LambdaPiF scope (f a) -&gt; f (LambdaPiF scope a)
forall scope (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; LambdaPiF scope a -&gt; m (LambdaPiF scope b)
forall scope (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; LambdaPiF scope a -&gt; f (LambdaPiF scope b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
LambdaPiF scope (m a) -&gt; m (LambdaPiF scope a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
LambdaPiF scope (f a) -&gt; f (LambdaPiF scope a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; LambdaPiF scope a -&gt; m (LambdaPiF scope b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; LambdaPiF scope a -&gt; f (LambdaPiF scope b)
$ctraverse :: forall scope (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; LambdaPiF scope a -&gt; f (LambdaPiF scope b)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; LambdaPiF scope a -&gt; f (LambdaPiF scope b)
$csequenceA :: forall scope (f :: * -&gt; *) a.
Applicative f =&gt;
LambdaPiF scope (f a) -&gt; f (LambdaPiF scope a)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
LambdaPiF scope (f a) -&gt; f (LambdaPiF scope a)
$cmapM :: forall scope (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; LambdaPiF scope a -&gt; m (LambdaPiF scope b)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; LambdaPiF scope a -&gt; m (LambdaPiF scope b)
$csequence :: forall scope (m :: * -&gt; *) a.
Monad m =&gt;
LambdaPiF scope (m a) -&gt; m (LambdaPiF scope a)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
LambdaPiF scope (m a) -&gt; m (LambdaPiF scope a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span id="local-6989586621679246031"><span id="local-6989586621679246033"><span id="local-6989586621679246037"><span class="hs-identifier">deriveBifunctor</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">LambdaPiF</span></span></span></span><span>
</span><span id="line-60"></span><span id="local-6989586621679246051"><span id="local-6989586621679246057"><span id="local-6989586621679246063"><span id="local-6989586621679246065"><span class="hs-identifier">deriveBifoldable</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">LambdaPiF</span></span></span></span></span><span>
</span><span id="line-61"></span><span id="local-6989586621679246094"><span class="hs-identifier">deriveBitraversable</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">LambdaPiF</span></span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ZipMatch</span></span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPiF"><span class="hs-identifier hs-type">LambdaPiF</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-64"></span><span>  </span><span id="local-6989586621679246122"><span class="annot"><span class="annottext">zipMatch :: forall scope term scope' term'.
LambdaPiF scope term
-&gt; LambdaPiF scope' term'
-&gt; Maybe (LambdaPiF (scope, scope') (term, term'))
</span><a href="#local-6989586621679246122"><span class="hs-identifier hs-var hs-var hs-var hs-var">zipMatch</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#AppF"><span class="hs-identifier hs-type">AppF</span></a></span><span> </span><span id="local-6989586621679246124"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246124"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246125"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246125"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#AppF"><span class="hs-identifier hs-type">AppF</span></a></span><span> </span><span id="local-6989586621679246126"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246126"><span class="hs-identifier hs-var">l'</span></a></span></span><span> </span><span id="local-6989586621679246127"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246127"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LambdaPiF (scope, scope') (term, term')
-&gt; Maybe (LambdaPiF (scope, scope') (term, term'))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(term, term')
-&gt; (term, term') -&gt; LambdaPiF (scope, scope') (term, term')
forall scope term. term -&gt; term -&gt; LambdaPiF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#AppF"><span class="hs-identifier hs-var">AppF</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246124"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246126"><span class="hs-identifier hs-var">l'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246125"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246127"><span class="hs-identifier hs-var">r'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span>  </span><span class="annot"><span class="hs-identifier hs-var">zipMatch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LamF"><span class="hs-identifier hs-type">LamF</span></a></span><span> </span><span id="local-6989586621679246128"><span class="annot"><span class="annottext">scope
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LamF"><span class="hs-identifier hs-type">LamF</span></a></span><span> </span><span id="local-6989586621679246129"><span class="annot"><span class="annottext">scope'
</span><a href="#local-6989586621679246129"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LambdaPiF (scope, scope') (term, term')
-&gt; Maybe (LambdaPiF (scope, scope') (term, term'))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(scope, scope') -&gt; LambdaPiF (scope, scope') (term, term')
forall scope term. scope -&gt; LambdaPiF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#LamF"><span class="hs-identifier hs-var">LamF</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">scope
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">scope'
</span><a href="#local-6989586621679246129"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-66"></span><span>  </span><span class="annot"><span class="hs-identifier hs-var">zipMatch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PiF"><span class="hs-identifier hs-type">PiF</span></a></span><span> </span><span id="local-6989586621679246130"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246130"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246131"><span class="annot"><span class="annottext">scope
</span><a href="#local-6989586621679246131"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PiF"><span class="hs-identifier hs-type">PiF</span></a></span><span> </span><span id="local-6989586621679246132"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246132"><span class="hs-identifier hs-var">l'</span></a></span></span><span> </span><span id="local-6989586621679246133"><span class="annot"><span class="annottext">scope'
</span><a href="#local-6989586621679246133"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LambdaPiF (scope, scope') (term, term')
-&gt; Maybe (LambdaPiF (scope, scope') (term, term'))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(term, term')
-&gt; (scope, scope') -&gt; LambdaPiF (scope, scope') (term, term')
forall scope term. term -&gt; scope -&gt; LambdaPiF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#PiF"><span class="hs-identifier hs-var">PiF</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246130"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246132"><span class="hs-identifier hs-var">l'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">scope
</span><a href="#local-6989586621679246131"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">scope'
</span><a href="#local-6989586621679246133"><span class="hs-identifier hs-var">r'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-67"></span><span>  </span><span class="annot"><span class="hs-identifier hs-var">zipMatch</span></span><span> </span><span class="annot"><span class="annottext">LambdaPiF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#UniverseF"><span class="hs-identifier hs-var">UniverseF</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPiF scope' term'
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#UniverseF"><span class="hs-identifier hs-var">UniverseF</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LambdaPiF (scope, scope') (term, term')
-&gt; Maybe (LambdaPiF (scope, scope') (term, term'))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">LambdaPiF (scope, scope') (term, term')
forall scope term. LambdaPiF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#UniverseF"><span class="hs-identifier hs-var">UniverseF</span></a></span><span>
</span><span id="line-68"></span><span>  </span><span class="annot"><span class="hs-identifier hs-var">zipMatch</span></span><span> </span><span class="annot"><span class="annottext">LambdaPiF scope term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LambdaPiF scope' term'
</span><span class="hs-identifier">_</span></span><span>                     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (LambdaPiF (scope, scope') (term, term'))
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span class="annot"><span class="hs-comment">-- | The signature 'Bifunctor' for pairs.</span></span><span>
</span><span id="line-71"></span><span class="hs-keyword">data</span><span> </span><span id="PairF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PairF"><span class="hs-identifier hs-var">PairF</span></a></span></span><span> </span><span id="local-6989586621679245681"><span class="annot"><a href="#local-6989586621679245681"><span class="hs-identifier hs-type">scope</span></a></span></span><span> </span><span id="local-6989586621679245680"><span class="annot"><a href="#local-6989586621679245680"><span class="hs-identifier hs-type">term</span></a></span></span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="PairF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PairF"><span class="hs-identifier hs-var">PairF</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679245680"><span class="hs-identifier hs-type">term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245680"><span class="hs-identifier hs-type">term</span></a></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Pair: \(\langle t_1, t_2 \rangle\)</span></span><span>
</span><span id="line-73"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FirstF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#FirstF"><span class="hs-identifier hs-var">FirstF</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679245680"><span class="hs-identifier hs-type">term</span></a></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ First projection: \(\pi_1(t)\)</span></span><span>
</span><span id="line-74"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SecondF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#SecondF"><span class="hs-identifier hs-var">SecondF</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679245680"><span class="hs-identifier hs-type">term</span></a></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ Second projection: \(\pi_2(t)\)</span></span><span>
</span><span id="line-75"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ProductF"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#ProductF"><span class="hs-identifier hs-var">ProductF</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679245680"><span class="hs-identifier hs-type">term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245680"><span class="hs-identifier hs-type">term</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ Product type (non-dependent): \(T_1 \times T_2\)</span></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679246140"><span id="local-6989586621679246148"><span class="annot"><span class="annottext">PairF scope term -&gt; PairF scope term -&gt; Bool
(PairF scope term -&gt; PairF scope term -&gt; Bool)
-&gt; (PairF scope term -&gt; PairF scope term -&gt; Bool)
-&gt; Eq (PairF scope term)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall scope term.
Eq term =&gt;
PairF scope term -&gt; PairF scope term -&gt; Bool
$c== :: forall scope term.
Eq term =&gt;
PairF scope term -&gt; PairF scope term -&gt; Bool
== :: PairF scope term -&gt; PairF scope term -&gt; Bool
$c/= :: forall scope term.
Eq term =&gt;
PairF scope term -&gt; PairF scope term -&gt; Bool
/= :: PairF scope term -&gt; PairF scope term -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246153"><span id="local-6989586621679246165"><span id="local-6989586621679246169"><span class="annot"><span class="annottext">Int -&gt; PairF scope term -&gt; ShowS
[PairF scope term] -&gt; ShowS
PairF scope term -&gt; String
(Int -&gt; PairF scope term -&gt; ShowS)
-&gt; (PairF scope term -&gt; String)
-&gt; ([PairF scope term] -&gt; ShowS)
-&gt; Show (PairF scope term)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall scope term. Show term =&gt; Int -&gt; PairF scope term -&gt; ShowS
forall scope term. Show term =&gt; [PairF scope term] -&gt; ShowS
forall scope term. Show term =&gt; PairF scope term -&gt; String
$cshowsPrec :: forall scope term. Show term =&gt; Int -&gt; PairF scope term -&gt; ShowS
showsPrec :: Int -&gt; PairF scope term -&gt; ShowS
$cshow :: forall scope term. Show term =&gt; PairF scope term -&gt; String
show :: PairF scope term -&gt; String
$cshowList :: forall scope term. Show term =&gt; [PairF scope term] -&gt; ShowS
showList :: [PairF scope term] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246172"><span id="local-6989586621679246174"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; PairF scope a -&gt; PairF scope b)
-&gt; (forall a b. a -&gt; PairF scope b -&gt; PairF scope a)
-&gt; Functor (PairF scope)
forall a b. a -&gt; PairF scope b -&gt; PairF scope a
forall a b. (a -&gt; b) -&gt; PairF scope a -&gt; PairF scope b
forall scope a b. a -&gt; PairF scope b -&gt; PairF scope a
forall scope a b. (a -&gt; b) -&gt; PairF scope a -&gt; PairF scope b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall scope a b. (a -&gt; b) -&gt; PairF scope a -&gt; PairF scope b
fmap :: forall a b. (a -&gt; b) -&gt; PairF scope a -&gt; PairF scope b
$c&lt;$ :: forall scope a b. a -&gt; PairF scope b -&gt; PairF scope a
&lt;$ :: forall a b. a -&gt; PairF scope b -&gt; PairF scope a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246177"><span id="local-6989586621679246183"><span id="local-6989586621679246188"><span id="local-6989586621679246193"><span id="local-6989586621679246195"><span id="local-6989586621679246198"><span id="local-6989586621679246201"><span id="local-6989586621679246204"><span id="local-6989586621679246207"><span id="local-6989586621679246210"><span id="local-6989586621679246213"><span id="local-6989586621679246215"><span id="local-6989586621679246218"><span id="local-6989586621679246223"><span id="local-6989586621679246228"><span id="local-6989586621679246233"><span id="local-6989586621679246238"><span class="annot"><span class="annottext">(forall m. Monoid m =&gt; PairF scope m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PairF scope a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PairF scope a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; PairF scope a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; PairF scope a -&gt; a)
-&gt; (forall a. PairF scope a -&gt; [a])
-&gt; (forall a. PairF scope a -&gt; Bool)
-&gt; (forall a. PairF scope a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; PairF scope a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; PairF scope a -&gt; a)
-&gt; (forall a. Ord a =&gt; PairF scope a -&gt; a)
-&gt; (forall a. Num a =&gt; PairF scope a -&gt; a)
-&gt; (forall a. Num a =&gt; PairF scope a -&gt; a)
-&gt; Foldable (PairF scope)
forall a. Eq a =&gt; a -&gt; PairF scope a -&gt; Bool
forall a. Num a =&gt; PairF scope a -&gt; a
forall a. Ord a =&gt; PairF scope a -&gt; a
forall m. Monoid m =&gt; PairF scope m -&gt; m
forall a. PairF scope a -&gt; Bool
forall a. PairF scope a -&gt; Int
forall a. PairF scope a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; PairF scope a -&gt; a
forall scope a. Eq a =&gt; a -&gt; PairF scope a -&gt; Bool
forall scope a. Num a =&gt; PairF scope a -&gt; a
forall scope a. Ord a =&gt; PairF scope a -&gt; a
forall scope m. Monoid m =&gt; PairF scope m -&gt; m
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PairF scope a -&gt; m
forall scope a. PairF scope a -&gt; Bool
forall scope a. PairF scope a -&gt; Int
forall scope a. PairF scope a -&gt; [a]
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
forall scope a. (a -&gt; a -&gt; a) -&gt; PairF scope a -&gt; a
forall scope m a. Monoid m =&gt; (a -&gt; m) -&gt; PairF scope a -&gt; m
forall scope b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
forall scope a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
$cfold :: forall scope m. Monoid m =&gt; PairF scope m -&gt; m
fold :: forall m. Monoid m =&gt; PairF scope m -&gt; m
$cfoldMap :: forall scope m a. Monoid m =&gt; (a -&gt; m) -&gt; PairF scope a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PairF scope a -&gt; m
$cfoldMap' :: forall scope m a. Monoid m =&gt; (a -&gt; m) -&gt; PairF scope a -&gt; m
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PairF scope a -&gt; m
$cfoldr :: forall scope a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
$cfoldr' :: forall scope a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
$cfoldl :: forall scope b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
$cfoldl' :: forall scope b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PairF scope a -&gt; b
$cfoldr1 :: forall scope a. (a -&gt; a -&gt; a) -&gt; PairF scope a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; PairF scope a -&gt; a
$cfoldl1 :: forall scope a. (a -&gt; a -&gt; a) -&gt; PairF scope a -&gt; a
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; PairF scope a -&gt; a
$ctoList :: forall scope a. PairF scope a -&gt; [a]
toList :: forall a. PairF scope a -&gt; [a]
$cnull :: forall scope a. PairF scope a -&gt; Bool
null :: forall a. PairF scope a -&gt; Bool
$clength :: forall scope a. PairF scope a -&gt; Int
length :: forall a. PairF scope a -&gt; Int
$celem :: forall scope a. Eq a =&gt; a -&gt; PairF scope a -&gt; Bool
elem :: forall a. Eq a =&gt; a -&gt; PairF scope a -&gt; Bool
$cmaximum :: forall scope a. Ord a =&gt; PairF scope a -&gt; a
maximum :: forall a. Ord a =&gt; PairF scope a -&gt; a
$cminimum :: forall scope a. Ord a =&gt; PairF scope a -&gt; a
minimum :: forall a. Ord a =&gt; PairF scope a -&gt; a
$csum :: forall scope a. Num a =&gt; PairF scope a -&gt; a
sum :: forall a. Num a =&gt; PairF scope a -&gt; a
$cproduct :: forall scope a. Num a =&gt; PairF scope a -&gt; a
product :: forall a. Num a =&gt; PairF scope a -&gt; a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246247"><span id="local-6989586621679246255"><span id="local-6989586621679246261"><span id="local-6989586621679246266"><span class="annot"><span class="annottext">Functor (PairF scope)
Foldable (PairF scope)
(Functor (PairF scope), Foldable (PairF scope)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; PairF scope a -&gt; f (PairF scope b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    PairF scope (f a) -&gt; f (PairF scope a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; PairF scope a -&gt; m (PairF scope b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    PairF scope (m a) -&gt; m (PairF scope a))
-&gt; Traversable (PairF scope)
forall scope. Functor (PairF scope)
forall scope. Foldable (PairF scope)
forall scope (m :: * -&gt; *) a.
Monad m =&gt;
PairF scope (m a) -&gt; m (PairF scope a)
forall scope (f :: * -&gt; *) a.
Applicative f =&gt;
PairF scope (f a) -&gt; f (PairF scope a)
forall scope (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PairF scope a -&gt; m (PairF scope b)
forall scope (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PairF scope a -&gt; f (PairF scope b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
PairF scope (m a) -&gt; m (PairF scope a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
PairF scope (f a) -&gt; f (PairF scope a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PairF scope a -&gt; m (PairF scope b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PairF scope a -&gt; f (PairF scope b)
$ctraverse :: forall scope (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PairF scope a -&gt; f (PairF scope b)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PairF scope a -&gt; f (PairF scope b)
$csequenceA :: forall scope (f :: * -&gt; *) a.
Applicative f =&gt;
PairF scope (f a) -&gt; f (PairF scope a)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
PairF scope (f a) -&gt; f (PairF scope a)
$cmapM :: forall scope (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PairF scope a -&gt; m (PairF scope b)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PairF scope a -&gt; m (PairF scope b)
$csequence :: forall scope (m :: * -&gt; *) a.
Monad m =&gt;
PairF scope (m a) -&gt; m (PairF scope a)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
PairF scope (m a) -&gt; m (PairF scope a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-77"></span><span id="local-6989586621679246273"><span id="local-6989586621679246275"><span id="local-6989586621679246279"><span class="hs-identifier">deriveBifunctor</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">PairF</span></span></span></span><span>
</span><span id="line-78"></span><span id="local-6989586621679246291"><span id="local-6989586621679246297"><span id="local-6989586621679246302"><span id="local-6989586621679246304"><span class="hs-identifier">deriveBifoldable</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">PairF</span></span></span></span></span><span>
</span><span id="line-79"></span><span id="local-6989586621679246330"><span class="hs-identifier">deriveBitraversable</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">PairF</span></span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ZipMatch</span></span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PairF"><span class="hs-identifier hs-type">PairF</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-82"></span><span>  </span><span id="local-6989586621679246355"><span class="annot"><span class="annottext">zipMatch :: forall scope term scope' term'.
PairF scope term
-&gt; PairF scope' term'
-&gt; Maybe (PairF (scope, scope') (term, term'))
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">zipMatch</span></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PairF"><span class="hs-identifier hs-type">PairF</span></a></span><span> </span><span id="local-6989586621679246356"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246356"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246357"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246357"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PairF"><span class="hs-identifier hs-type">PairF</span></a></span><span> </span><span id="local-6989586621679246358"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246358"><span class="hs-identifier hs-var">l'</span></a></span></span><span> </span><span id="local-6989586621679246359"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246359"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PairF (scope, scope') (term, term')
-&gt; Maybe (PairF (scope, scope') (term, term'))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(term, term')
-&gt; (term, term') -&gt; PairF (scope, scope') (term, term')
forall scope term. term -&gt; term -&gt; PairF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#PairF"><span class="hs-identifier hs-var">PairF</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246356"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246358"><span class="hs-identifier hs-var">l'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246357"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246359"><span class="hs-identifier hs-var">r'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span>  </span><span class="annot"><span class="hs-identifier hs-var">zipMatch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#FirstF"><span class="hs-identifier hs-type">FirstF</span></a></span><span> </span><span id="local-6989586621679246360"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246360"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#FirstF"><span class="hs-identifier hs-type">FirstF</span></a></span><span> </span><span id="local-6989586621679246361"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246361"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PairF (scope, scope') (term, term')
-&gt; Maybe (PairF (scope, scope') (term, term'))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(term, term') -&gt; PairF (scope, scope') (term, term')
forall scope term. term -&gt; PairF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#FirstF"><span class="hs-identifier hs-var">FirstF</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246360"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246361"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-84"></span><span>  </span><span class="annot"><span class="hs-identifier hs-var">zipMatch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#SecondF"><span class="hs-identifier hs-type">SecondF</span></a></span><span> </span><span id="local-6989586621679246362"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246362"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#SecondF"><span class="hs-identifier hs-type">SecondF</span></a></span><span> </span><span id="local-6989586621679246363"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246363"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PairF (scope, scope') (term, term')
-&gt; Maybe (PairF (scope, scope') (term, term'))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(term, term') -&gt; PairF (scope, scope') (term, term')
forall scope term. term -&gt; PairF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#SecondF"><span class="hs-identifier hs-var">SecondF</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246362"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246363"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-85"></span><span>  </span><span class="annot"><span class="hs-identifier hs-var">zipMatch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#ProductF"><span class="hs-identifier hs-type">ProductF</span></a></span><span> </span><span id="local-6989586621679246364"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246364"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246365"><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246365"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#ProductF"><span class="hs-identifier hs-type">ProductF</span></a></span><span> </span><span id="local-6989586621679246366"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246366"><span class="hs-identifier hs-var">l'</span></a></span></span><span> </span><span id="local-6989586621679246367"><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246367"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PairF (scope, scope') (term, term')
-&gt; Maybe (PairF (scope, scope') (term, term'))
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(term, term')
-&gt; (term, term') -&gt; PairF (scope, scope') (term, term')
forall scope term. term -&gt; term -&gt; PairF scope term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#ProductF"><span class="hs-identifier hs-var">ProductF</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246364"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246366"><span class="hs-identifier hs-var">l'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">term
</span><a href="#local-6989586621679246365"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">term'
</span><a href="#local-6989586621679246367"><span class="hs-identifier hs-var">r'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-86"></span><span>  </span><span class="annot"><span class="hs-identifier hs-var">zipMatch</span></span><span> </span><span class="annot"><span class="annottext">PairF scope term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">PairF scope' term'
</span><span class="hs-identifier">_</span></span><span>                             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (PairF (scope, scope') (term, term'))
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span class="annot"><span class="hs-comment">-- | Sum of signature bifunctors.</span></span><span>
</span><span id="line-89"></span><span class="hs-keyword">type</span><span> </span><span id="%3A%2B%3A"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#%3A%2B%3A"><span class="hs-operator hs-var">(:+:)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="annot"><span class="hs-comment">-- | \(\lambda\Pi\)-terms in scope @n@, freely generated from the sum of signatures 'LambdaPiF' and t'PairF'.</span></span><span>
</span><span id="line-92"></span><span class="hs-keyword">type</span><span> </span><span id="LambdaPi"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-var">LambdaPi</span></a></span></span><span> </span><span id="local-6989586621679246368"><span class="annot"><a href="#local-6989586621679246368"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.NameBinder</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPiF"><span class="hs-identifier hs-type">LambdaPiF</span></a></span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#%3A%2B%3A"><span class="hs-operator hs-type">:+:</span></a></span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PairF"><span class="hs-identifier hs-type">PairF</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679246368"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245700"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245700"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245700"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245700"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-95"></span><span class="hs-keyword">pattern</span><span> </span><span id="App"><span id="%24mApp"><span id="%24bApp"><span class="annot"><span class="annottext">$mApp :: forall {r} {n :: S}.
LambdaPi n -&gt; (LambdaPi n -&gt; LambdaPi n -&gt; r) -&gt; ((# #) -&gt; r) -&gt; r
$bApp :: forall (n :: S). LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#App"><span class="hs-identifier hs-var hs-var hs-var">App</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246372"><span class="hs-identifier hs-type">fun</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246373"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#AppF"><span class="hs-identifier hs-type">AppF</span></a></span><span> </span><span id="local-6989586621679246372"><span class="annot"><a href="#local-6989586621679246372"><span class="hs-identifier hs-var">fun</span></a></span></span><span> </span><span id="local-6989586621679246373"><span class="annot"><a href="#local-6989586621679246373"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Lam"><span class="hs-identifier hs-type">Lam</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245719"><span id="local-6989586621679245720"><span class="annot"><span class="hs-identifier hs-type">Foil.NameBinder</span></span><span> </span><span class="annot"><a href="#local-6989586621679245719"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245720"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245720"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245719"><span class="hs-identifier hs-type">n</span></a></span></span></span><span>
</span><span id="line-98"></span><span class="hs-keyword">pattern</span><span> </span><span id="Lam"><span id="%24mLam"><span id="%24bLam"><span class="annot"><span class="annottext">$mLam :: forall {r} {n :: S}.
LambdaPi n
-&gt; (forall {l :: S}. NameBinder n l -&gt; LambdaPi l -&gt; r)
-&gt; ((# #) -&gt; r)
-&gt; r
$bLam :: forall (n :: S) (l :: S).
NameBinder n l -&gt; LambdaPi l -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Lam"><span class="hs-identifier hs-var hs-var hs-var">Lam</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246379"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246380"><span class="hs-identifier hs-type">body</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LamF"><span class="hs-identifier hs-type">LamF</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ScopedAST</span></span><span> </span><span id="local-6989586621679246379"><span class="annot"><a href="#local-6989586621679246379"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246380"><span class="annot"><a href="#local-6989586621679246380"><span class="hs-identifier hs-var">body</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pi"><span class="hs-identifier hs-type">Pi</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245730"><span id="local-6989586621679245731"><span class="annot"><span class="hs-identifier hs-type">Foil.NameBinder</span></span><span> </span><span class="annot"><a href="#local-6989586621679245730"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245731"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245730"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245731"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245730"><span class="hs-identifier hs-type">n</span></a></span></span></span><span>
</span><span id="line-101"></span><span class="hs-keyword">pattern</span><span> </span><span id="Pi"><span id="%24mPi"><span id="%24bPi"><span class="annot"><span class="annottext">$mPi :: forall {r} {n :: S}.
LambdaPi n
-&gt; (forall {l :: S}.
    NameBinder n l -&gt; LambdaPi n -&gt; LambdaPi l -&gt; r)
-&gt; ((# #) -&gt; r)
-&gt; r
$bPi :: forall (n :: S) (l :: S).
NameBinder n l -&gt; LambdaPi n -&gt; LambdaPi l -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Pi"><span class="hs-identifier hs-var hs-var hs-var">Pi</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246385"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246386"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246387"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PiF"><span class="hs-identifier hs-type">PiF</span></a></span><span> </span><span id="local-6989586621679246386"><span class="annot"><a href="#local-6989586621679246386"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ScopedAST</span></span><span> </span><span id="local-6989586621679246385"><span class="annot"><a href="#local-6989586621679246385"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246387"><span class="annot"><a href="#local-6989586621679246387"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pair"><span class="hs-identifier hs-type">Pair</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245738"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245738"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245738"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245738"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-104"></span><span class="hs-keyword">pattern</span><span> </span><span id="Pair"><span id="%24mPair"><span id="%24bPair"><span class="annot"><span class="annottext">$mPair :: forall {r} {n :: S}.
LambdaPi n -&gt; (LambdaPi n -&gt; LambdaPi n -&gt; r) -&gt; ((# #) -&gt; r) -&gt; r
$bPair :: forall (n :: S). LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Pair"><span class="hs-identifier hs-var hs-var hs-var">Pair</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246391"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246392"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">R2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#PairF"><span class="hs-identifier hs-type">PairF</span></a></span><span> </span><span id="local-6989586621679246391"><span class="annot"><a href="#local-6989586621679246391"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246392"><span class="annot"><a href="#local-6989586621679246392"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#First"><span class="hs-identifier hs-type">First</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245740"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245740"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245740"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-107"></span><span class="hs-keyword">pattern</span><span> </span><span id="First"><span id="%24mFirst"><span id="%24bFirst"><span class="annot"><span class="annottext">$mFirst :: forall {r} {n :: S}.
LambdaPi n -&gt; (LambdaPi n -&gt; r) -&gt; ((# #) -&gt; r) -&gt; r
$bFirst :: forall (n :: S). LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#First"><span class="hs-identifier hs-var hs-var hs-var">First</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246397"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">R2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#FirstF"><span class="hs-identifier hs-type">FirstF</span></a></span><span> </span><span id="local-6989586621679246397"><span class="annot"><a href="#local-6989586621679246397"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Second"><span class="hs-identifier hs-type">Second</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245745"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245745"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245745"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-110"></span><span class="hs-keyword">pattern</span><span> </span><span id="Second"><span id="%24mSecond"><span id="%24bSecond"><span class="annot"><span class="annottext">$mSecond :: forall {r} {n :: S}.
LambdaPi n -&gt; (LambdaPi n -&gt; r) -&gt; ((# #) -&gt; r) -&gt; r
$bSecond :: forall (n :: S). LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Second"><span class="hs-identifier hs-var hs-var hs-var">Second</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246401"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">R2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#SecondF"><span class="hs-identifier hs-type">SecondF</span></a></span><span> </span><span id="local-6989586621679246401"><span class="annot"><a href="#local-6989586621679246401"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Product"><span class="hs-identifier hs-type">Product</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245748"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245748"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245748"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245748"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-113"></span><span class="hs-keyword">pattern</span><span> </span><span id="Product"><span id="%24mProduct"><span id="%24bProduct"><span class="annot"><span class="annottext">$mProduct :: forall {r} {n :: S}.
LambdaPi n -&gt; (LambdaPi n -&gt; LambdaPi n -&gt; r) -&gt; ((# #) -&gt; r) -&gt; r
$bProduct :: forall (n :: S). LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Product"><span class="hs-identifier hs-var hs-var hs-var">Product</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246405"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246406"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">R2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#ProductF"><span class="hs-identifier hs-type">ProductF</span></a></span><span> </span><span id="local-6989586621679246405"><span class="annot"><a href="#local-6989586621679246405"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246406"><span class="annot"><a href="#local-6989586621679246406"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>
</span><span id="line-115"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Universe"><span class="hs-identifier hs-type">Universe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245750"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245750"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-116"></span><span class="hs-keyword">pattern</span><span> </span><span id="Universe"><span id="%24mUniverse"><span id="%24bUniverse"><span class="annot"><span class="annottext">$mUniverse :: forall {r} {n :: S}.
LambdaPi n -&gt; ((# #) -&gt; r) -&gt; ((# #) -&gt; r) -&gt; r
$bUniverse :: forall (n :: S). LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Universe"><span class="hs-identifier hs-var hs-var hs-var">Universe</span></a></span></span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#UniverseF"><span class="hs-identifier hs-type">UniverseF</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-pragma">{-# COMPLETE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">Var</span></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#App"><span class="hs-pragma hs-type">App</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Lam"><span class="hs-pragma hs-type">Lam</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pi"><span class="hs-pragma hs-type">Pi</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pair"><span class="hs-pragma hs-type">Pair</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#First"><span class="hs-pragma hs-type">First</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Second"><span class="hs-pragma hs-type">Second</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Product"><span class="hs-pragma hs-type">Product</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Universe"><span class="hs-pragma hs-type">Universe</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span class="annot"><span class="hs-comment">-- | \(\lambda\Pi\)-terms are pretty-printed using BNFC-generated printer via 'Raw.Term'.</span></span><span>
</span><span id="line-121"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679246412"><span id="local-6989586621679246417"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-122"></span><span>  </span><span id="local-6989586621679246419"><span class="annot"><span class="annottext">show :: LambdaPi 'VoidS -&gt; String
</span><a href="#local-6989586621679246419"><span class="hs-identifier hs-var hs-var hs-var hs-var">show</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LambdaPi 'VoidS -&gt; String
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#ppLambdaPi"><span class="hs-identifier hs-var">ppLambdaPi</span></a></span><span>
</span><span id="line-123"></span><span>
</span><span id="line-124"></span><span class="annot"><span class="hs-comment">-- | \(\lambda\Pi\)-terms can be (unsafely) parsed from a 'String' via 'Raw.Term'.</span></span><span>
</span><span id="line-125"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IsString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-126"></span><span>  </span><span id="local-6989586621679246431"><span class="annot"><span class="annottext">fromString :: String -&gt; LambdaPi 'VoidS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fromString</span></span></span><span> </span><span id="local-6989586621679246432"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246432"><span class="hs-identifier hs-var">input</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-127"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Token] -&gt; Err Term
</span><a href="Language.LambdaPi.Syntax.Par.html#pTerm"><span class="hs-identifier hs-var">Raw.pTerm</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; [Token]
</span><a href="Language.LambdaPi.Syntax.Lex.html#tokens"><span class="hs-identifier hs-var">Raw.tokens</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246432"><span class="hs-identifier hs-var">input</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-128"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679246435"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246435"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; LambdaPi 'VoidS
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;could not parse &#955;&#928;-term: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246432"><span class="hs-identifier hs-var">input</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246435"><span class="hs-identifier hs-var">err</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-129"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679246437"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246437"><span class="hs-identifier hs-var">term</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; LambdaPi 'VoidS
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiClosed"><span class="hs-identifier hs-var">toLambdaPiClosed</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246437"><span class="hs-identifier hs-var">term</span></a></span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span class="hs-comment">-- | Compute weak head normal form (WHNF) of a \(\lambda\Pi\)-term.</span><span>
</span><span id="line-132"></span><span class="hs-comment">--</span><span>
</span><span id="line-133"></span><span class="hs-comment">-- &gt;&gt;&gt; whnf Foil.emptyScope &quot;(&#955;x.(&#955;_.x)(&#955;y.x))(&#955;y.&#955;z.z)&quot;</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- &#955; x0 . &#955; x1 . x1</span><span>
</span><span id="line-135"></span><span class="hs-comment">--</span><span>
</span><span id="line-136"></span><span class="hs-comment">-- &gt;&gt;&gt; whnf Foil.emptyScope &quot;(&#955;s.&#955;z.s(s(z)))(&#955;s.&#955;z.s(s(z)))&quot;</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- &#955; x1 . (&#955; x0 . &#955; x1 . x0 (x0 x1)) ((&#955; x0 . &#955; x1 . x0 (x0 x1)) x1)</span><span>
</span><span id="line-138"></span><span class="hs-comment">--</span><span>
</span><span id="line-139"></span><span class="hs-comment">-- Note that during computation bound variables can become unordered</span><span>
</span><span id="line-140"></span><span class="hs-comment">-- in the sense that binders may easily repeat or decrease. For example,</span><span>
</span><span id="line-141"></span><span class="hs-comment">-- in the following expression, inner binder has lower index that the outer one:</span><span>
</span><span id="line-142"></span><span class="hs-comment">--</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- &gt;&gt;&gt; whnf Foil.emptyScope &quot;(&#955;x.&#955;y.x)(&#955;x.x)&quot;</span><span>
</span><span id="line-144"></span><span class="hs-comment">-- &#955; x1 . &#955; x0 . x0</span><span>
</span><span id="line-145"></span><span class="hs-comment">--</span><span>
</span><span id="line-146"></span><span class="hs-comment">-- At the same time, without substitution, we get regular, increasing binder indices:</span><span>
</span><span id="line-147"></span><span class="hs-comment">--</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- &gt;&gt;&gt; &quot;&#955;x.&#955;y.y&quot; :: LambdaPi Foil.VoidS</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- &#955; x0 . &#955; x1 . x1</span><span>
</span><span id="line-150"></span><span class="hs-comment">--</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- To compare terms for \(\alpha\)-equivalence, we may use 'alphaEquiv':</span><span>
</span><span id="line-152"></span><span class="hs-comment">--</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- &gt;&gt;&gt; alphaEquiv Foil.emptyScope (whnf Foil.emptyScope &quot;(&#955;x.&#955;y.x)(&#955;x.x)&quot;) &quot;&#955;x.&#955;y.y&quot;</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-155"></span><span class="hs-comment">--</span><span>
</span><span id="line-156"></span><span class="hs-comment">-- We may also normalize binders using 'refreshAST':</span><span>
</span><span id="line-157"></span><span class="hs-comment">--</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- &gt;&gt;&gt; refreshAST Foil.emptyScope (whnf Foil.emptyScope &quot;(&#955;x.&#955;y.x)(&#955;x.x)&quot;)</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- &#955; x0 . &#955; x1 . x1</span><span>
</span><span id="line-160"></span><span id="local-6989586621679245761"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-type">whnf</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245761"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245761"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245761"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245761"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-161"></span><span id="whnf"><span class="annot"><span class="annottext">whnf :: forall (n :: S). Distinct n =&gt; Scope n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-var hs-var">whnf</span></a></span></span><span> </span><span id="local-6989586621679246445"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-162"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679246446"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246446"><span class="hs-identifier hs-var">fun</span></a></span></span><span> </span><span id="local-6989586621679246447"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246447"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-163"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). Distinct n =&gt; Scope n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246446"><span class="hs-identifier hs-var">fun</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-164"></span><span>      </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Lam"><span class="hs-identifier hs-type">Lam</span></a></span><span> </span><span id="local-6989586621679246458"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246458"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246459"><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246459"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-165"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246460"><span class="annot"><span class="annottext">subst :: Substitution (AST NameBinder (LambdaPiF :+: PairF)) l n
</span><a href="#local-6989586621679246460"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Substitution (AST NameBinder (LambdaPiF :+: PairF)) n n
-&gt; NameBinder n l
-&gt; LambdaPi n
-&gt; Substitution (AST NameBinder (LambdaPiF :+: PairF)) l n
forall (e :: S -&gt; *) (i :: S) (o :: S) (i' :: S).
Substitution e i o -&gt; NameBinder i i' -&gt; e o -&gt; Substitution e i' o
</span><span class="hs-identifier hs-var">Foil.addSubst</span></span><span> </span><span class="annot"><span class="annottext">Substitution (AST NameBinder (LambdaPiF :+: PairF)) n n
forall (e :: S -&gt; *) (i :: S). InjectName e =&gt; Substitution e i i
</span><span class="hs-identifier hs-var">Foil.identitySubst</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246458"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246447"><span class="hs-identifier hs-var">arg</span></a></span><span>
</span><span id="line-166"></span><span>        </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). Distinct n =&gt; Scope n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n
-&gt; Substitution (AST NameBinder (LambdaPiF :+: PairF)) l n
-&gt; LambdaPi l
-&gt; LambdaPi n
forall (sig :: * -&gt; * -&gt; *) (o :: S) (binder :: S -&gt; S -&gt; *)
       (i :: S).
(Bifunctor sig, Distinct o, CoSinkable binder) =&gt;
Scope o
-&gt; Substitution (AST binder sig) i o
-&gt; AST binder sig i
-&gt; AST binder sig o
</span><span class="hs-identifier hs-var">substitute</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Substitution (AST NameBinder (LambdaPiF :+: PairF)) l n
</span><a href="#local-6989586621679246460"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246459"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-167"></span><span>      </span><span id="local-6989586621679246463"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246463"><span class="hs-identifier hs-var">fun'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#App"><span class="hs-identifier hs-var">App</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246463"><span class="hs-identifier hs-var">fun'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246447"><span class="hs-identifier hs-var">arg</span></a></span><span>
</span><span id="line-168"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#First"><span class="hs-identifier hs-type">First</span></a></span><span> </span><span id="local-6989586621679246464"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246464"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-169"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). Distinct n =&gt; Scope n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246464"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-170"></span><span>      </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pair"><span class="hs-identifier hs-type">Pair</span></a></span><span> </span><span id="local-6989586621679246465"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246465"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246466"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246466"><span class="hs-identifier hs-var">_r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). Distinct n =&gt; Scope n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246465"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-171"></span><span>      </span><span id="local-6989586621679246467"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246467"><span class="hs-identifier hs-var">t'</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n -&gt; LambdaPi n
forall (n :: S). LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#First"><span class="hs-identifier hs-var">First</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246467"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-172"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Second"><span class="hs-identifier hs-type">Second</span></a></span><span> </span><span id="local-6989586621679246468"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246468"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-173"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). Distinct n =&gt; Scope n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246468"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-174"></span><span>      </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pair"><span class="hs-identifier hs-type">Pair</span></a></span><span> </span><span id="local-6989586621679246469"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246469"><span class="hs-identifier hs-var">_l</span></a></span></span><span> </span><span id="local-6989586621679246470"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246470"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). Distinct n =&gt; Scope n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246470"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-175"></span><span>      </span><span id="local-6989586621679246471"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246471"><span class="hs-identifier hs-var">t'</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n -&gt; LambdaPi n
forall (n :: S). LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Second"><span class="hs-identifier hs-var">Second</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246471"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-176"></span><span>  </span><span id="local-6989586621679246472"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246472"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246472"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span class="annot"><span class="hs-comment">-- | Convert a raw \(\lambda\)-abstraction into a scope-safe \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-179"></span><span id="local-6989586621679245782"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiLam"><span class="hs-identifier hs-type">toLambdaPiLam</span></a></span><span>
</span><span id="line-180"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245782"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-181"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245782"><span class="hs-identifier hs-type">n</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ Target scope of the \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-182"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679245782"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Mapping for the free variables in the raw term.</span></span><span>
</span><span id="line-183"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Pattern"><span class="hs-identifier hs-type">Raw.Pattern</span></a></span><span>                    </span><span class="annot"><span class="hs-comment">-- ^ Raw pattern (argument) of the \(\lambda\)-abstraction.</span></span><span>
</span><span id="line-184"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#ScopedTerm"><span class="hs-identifier hs-type">Raw.ScopedTerm</span></a></span><span>                 </span><span class="annot"><span class="hs-comment">-- ^ Raw body of the \(\lambda\)-abstraction.</span></span><span>
</span><span id="line-185"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245782"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-186"></span><span id="toLambdaPiLam"><span class="annot"><span class="annottext">toLambdaPiLam :: forall (n :: S).
Distinct n =&gt;
Scope n
-&gt; Map VarIdent (Name n) -&gt; Pattern -&gt; ScopedTerm -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiLam"><span class="hs-identifier hs-var hs-var">toLambdaPiLam</span></a></span></span><span> </span><span id="local-6989586621679246479"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246479"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246480"><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246480"><span class="hs-identifier hs-var">env</span></a></span></span><span> </span><span id="local-6989586621679246481"><span class="annot"><span class="annottext">Pattern
</span><a href="#local-6989586621679246481"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-type">Raw.AScopedTerm</span></a></span><span> </span><span id="local-6989586621679246483"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246483"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246484"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246484"><span class="hs-identifier hs-var">body</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-187"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Pattern
</span><a href="#local-6989586621679246481"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-188"></span><span>    </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#PatternWildcard"><span class="hs-identifier hs-type">Raw.PatternWildcard</span></a></span><span> </span><span id="local-6989586621679246486"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246486"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
-&gt; LambdaPi n
forall (n :: S) r.
Distinct n =&gt;
Scope n -&gt; (forall (l :: S). DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
</span><span class="hs-identifier hs-var">Foil.withFresh</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246479"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
 -&gt; LambdaPi n)
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
-&gt; LambdaPi n
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246496"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246496"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-189"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246497"><span class="annot"><span class="annottext">scope' :: Scope l
</span><a href="#local-6989586621679246497"><span class="hs-identifier hs-var hs-var">scope'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Scope n -&gt; Scope l
forall (n :: S) (l :: S). NameBinder n l -&gt; Scope n -&gt; Scope l
</span><span class="hs-identifier hs-var">Foil.extendScope</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246496"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246479"><span class="hs-identifier hs-var">scope</span></a></span><span>
</span><span id="line-190"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; LambdaPi l -&gt; LambdaPi n
forall (n :: S) (l :: S).
NameBinder n l -&gt; LambdaPi l -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Lam"><span class="hs-identifier hs-var">Lam</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246496"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope l -&gt; Map VarIdent (Name l) -&gt; Term -&gt; LambdaPi l
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246497"><span class="hs-identifier hs-var">scope'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name n -&gt; Name l
forall (e :: S -&gt; *) (n :: S) (l :: S).
(Sinkable e, DExt n l) =&gt;
e n -&gt; e l
</span><span class="hs-identifier hs-var">Foil.sink</span></span><span> </span><span class="annot"><span class="annottext">(Name n -&gt; Name l)
-&gt; Map VarIdent (Name n) -&gt; Map VarIdent (Name l)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246480"><span class="hs-identifier hs-var">env</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246484"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-191"></span><span>
</span><span id="line-192"></span><span>    </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#PatternVar"><span class="hs-identifier hs-type">Raw.PatternVar</span></a></span><span> </span><span id="local-6989586621679246502"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246502"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246503"><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246503"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
-&gt; LambdaPi n
forall (n :: S) r.
Distinct n =&gt;
Scope n -&gt; (forall (l :: S). DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
</span><span class="hs-identifier hs-var">Foil.withFresh</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246479"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
 -&gt; LambdaPi n)
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
-&gt; LambdaPi n
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246512"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246512"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-193"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246513"><span class="annot"><span class="annottext">scope' :: Scope l
</span><a href="#local-6989586621679246513"><span class="hs-identifier hs-var hs-var">scope'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Scope n -&gt; Scope l
forall (n :: S) (l :: S). NameBinder n l -&gt; Scope n -&gt; Scope l
</span><span class="hs-identifier hs-var">Foil.extendScope</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246512"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246479"><span class="hs-identifier hs-var">scope</span></a></span><span>
</span><span id="line-194"></span><span>          </span><span id="local-6989586621679246514"><span class="annot"><span class="annottext">env' :: Map VarIdent (Name l)
</span><a href="#local-6989586621679246514"><span class="hs-identifier hs-var hs-var">env'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarIdent
-&gt; Name l -&gt; Map VarIdent (Name l) -&gt; Map VarIdent (Name l)
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246503"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinder n l -&gt; Name l
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246512"><span class="hs-identifier hs-var">binder</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name n -&gt; Name l
forall (e :: S -&gt; *) (n :: S) (l :: S).
(Sinkable e, DExt n l) =&gt;
e n -&gt; e l
</span><span class="hs-identifier hs-var">Foil.sink</span></span><span> </span><span class="annot"><span class="annottext">(Name n -&gt; Name l)
-&gt; Map VarIdent (Name n) -&gt; Map VarIdent (Name l)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246480"><span class="hs-identifier hs-var">env</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; LambdaPi l -&gt; LambdaPi n
forall (n :: S) (l :: S).
NameBinder n l -&gt; LambdaPi l -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Lam"><span class="hs-identifier hs-var">Lam</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246512"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope l -&gt; Map VarIdent (Name l) -&gt; Term -&gt; LambdaPi l
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246513"><span class="hs-identifier hs-var">scope'</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name l)
</span><a href="#local-6989586621679246514"><span class="hs-identifier hs-var">env'</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246484"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span>
</span><span id="line-197"></span><span>    </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#PatternPair"><span class="hs-identifier hs-type">Raw.PatternPair</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; LambdaPi n
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pattern pairs are not supported in the FreeFoil example&quot;</span></span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="annot"><span class="hs-comment">-- | Convert a raw \(\Pi\)-type into a scope-safe \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-200"></span><span id="local-6989586621679245817"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiPi"><span class="hs-identifier hs-type">toLambdaPiPi</span></a></span><span>
</span><span id="line-201"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245817"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-202"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245817"><span class="hs-identifier hs-type">n</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ Target scope of the \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-203"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679245817"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Mapping for the free variables in the raw term.</span></span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Pattern"><span class="hs-identifier hs-type">Raw.Pattern</span></a></span><span>                    </span><span class="annot"><span class="hs-comment">-- ^ Raw argument pattern of the \(\Pi\)-type.</span></span><span>
</span><span id="line-205"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Term"><span class="hs-identifier hs-type">Raw.Term</span></a></span><span>                       </span><span class="annot"><span class="hs-comment">-- ^ Raw argument type of the \(\Pi\)-type.</span></span><span>
</span><span id="line-206"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#ScopedTerm"><span class="hs-identifier hs-type">Raw.ScopedTerm</span></a></span><span>                 </span><span class="annot"><span class="hs-comment">-- ^ Raw body (result type family) of the \(\Pi\)-type.</span></span><span>
</span><span id="line-207"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245817"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-208"></span><span id="toLambdaPiPi"><span class="annot"><span class="annottext">toLambdaPiPi :: forall (n :: S).
Distinct n =&gt;
Scope n
-&gt; Map VarIdent (Name n)
-&gt; Pattern
-&gt; Term
-&gt; ScopedTerm
-&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiPi"><span class="hs-identifier hs-var hs-var">toLambdaPiPi</span></a></span></span><span> </span><span id="local-6989586621679246524"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246524"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246525"><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246525"><span class="hs-identifier hs-var">env</span></a></span></span><span> </span><span id="local-6989586621679246526"><span class="annot"><span class="annottext">Pattern
</span><a href="#local-6989586621679246526"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621679246527"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246527"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-type">Raw.AScopedTerm</span></a></span><span> </span><span id="local-6989586621679246528"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246528"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246529"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246529"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-209"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Pattern
</span><a href="#local-6989586621679246526"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-210"></span><span>    </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#PatternWildcard"><span class="hs-identifier hs-type">Raw.PatternWildcard</span></a></span><span> </span><span id="local-6989586621679246530"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246530"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
-&gt; LambdaPi n
forall (n :: S) r.
Distinct n =&gt;
Scope n -&gt; (forall (l :: S). DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
</span><span class="hs-identifier hs-var">Foil.withFresh</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246524"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
 -&gt; LambdaPi n)
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
-&gt; LambdaPi n
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246538"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246538"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-211"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246539"><span class="annot"><span class="annottext">scope' :: Scope l
</span><a href="#local-6989586621679246539"><span class="hs-identifier hs-var hs-var">scope'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Scope n -&gt; Scope l
forall (n :: S) (l :: S). NameBinder n l -&gt; Scope n -&gt; Scope l
</span><span class="hs-identifier hs-var">Foil.extendScope</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246538"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246524"><span class="hs-identifier hs-var">scope</span></a></span><span>
</span><span id="line-212"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; LambdaPi n -&gt; LambdaPi l -&gt; LambdaPi n
forall (n :: S) (l :: S).
NameBinder n l -&gt; LambdaPi n -&gt; LambdaPi l -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Pi"><span class="hs-identifier hs-var">Pi</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246538"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246524"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246525"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246527"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope l -&gt; Map VarIdent (Name l) -&gt; Term -&gt; LambdaPi l
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246539"><span class="hs-identifier hs-var">scope'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name n -&gt; Name l
forall (e :: S -&gt; *) (n :: S) (l :: S).
(Sinkable e, DExt n l) =&gt;
e n -&gt; e l
</span><span class="hs-identifier hs-var">Foil.sink</span></span><span> </span><span class="annot"><span class="annottext">(Name n -&gt; Name l)
-&gt; Map VarIdent (Name n) -&gt; Map VarIdent (Name l)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246525"><span class="hs-identifier hs-var">env</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246529"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-213"></span><span>
</span><span id="line-214"></span><span>    </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#PatternVar"><span class="hs-identifier hs-type">Raw.PatternVar</span></a></span><span> </span><span id="local-6989586621679246540"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246540"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246541"><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246541"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
-&gt; LambdaPi n
forall (n :: S) r.
Distinct n =&gt;
Scope n -&gt; (forall (l :: S). DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
</span><span class="hs-identifier hs-var">Foil.withFresh</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246524"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
 -&gt; LambdaPi n)
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; LambdaPi n)
-&gt; LambdaPi n
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246550"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246550"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-215"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246551"><span class="annot"><span class="annottext">scope' :: Scope l
</span><a href="#local-6989586621679246551"><span class="hs-identifier hs-var hs-var">scope'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Scope n -&gt; Scope l
forall (n :: S) (l :: S). NameBinder n l -&gt; Scope n -&gt; Scope l
</span><span class="hs-identifier hs-var">Foil.extendScope</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246550"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246524"><span class="hs-identifier hs-var">scope</span></a></span><span>
</span><span id="line-216"></span><span>          </span><span id="local-6989586621679246552"><span class="annot"><span class="annottext">env' :: Map VarIdent (Name l)
</span><a href="#local-6989586621679246552"><span class="hs-identifier hs-var hs-var">env'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarIdent
-&gt; Name l -&gt; Map VarIdent (Name l) -&gt; Map VarIdent (Name l)
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246541"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinder n l -&gt; Name l
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246550"><span class="hs-identifier hs-var">binder</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name n -&gt; Name l
forall (e :: S -&gt; *) (n :: S) (l :: S).
(Sinkable e, DExt n l) =&gt;
e n -&gt; e l
</span><span class="hs-identifier hs-var">Foil.sink</span></span><span> </span><span class="annot"><span class="annottext">(Name n -&gt; Name l)
-&gt; Map VarIdent (Name n) -&gt; Map VarIdent (Name l)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246525"><span class="hs-identifier hs-var">env</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-217"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; LambdaPi n -&gt; LambdaPi l -&gt; LambdaPi n
forall (n :: S) (l :: S).
NameBinder n l -&gt; LambdaPi n -&gt; LambdaPi l -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Pi"><span class="hs-identifier hs-var">Pi</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246550"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246524"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246525"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246527"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope l -&gt; Map VarIdent (Name l) -&gt; Term -&gt; LambdaPi l
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246551"><span class="hs-identifier hs-var">scope'</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name l)
</span><a href="#local-6989586621679246552"><span class="hs-identifier hs-var">env'</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246529"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-218"></span><span>
</span><span id="line-219"></span><span>    </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#PatternPair"><span class="hs-identifier hs-type">Raw.PatternPair</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; LambdaPi n
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pattern pairs are not supported in the FreeFoil example&quot;</span></span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span class="annot"><span class="hs-comment">-- | Convert a raw expression into a scope-safe \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-222"></span><span id="local-6989586621679245805"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-type">toLambdaPi</span></a></span><span>
</span><span id="line-223"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245805"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-224"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245805"><span class="hs-identifier hs-type">n</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ Target scope of the \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-225"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679245805"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Mapping for the free variables in the raw term.</span></span><span>
</span><span id="line-226"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Term"><span class="hs-identifier hs-type">Raw.Term</span></a></span><span>                       </span><span class="annot"><span class="hs-comment">-- ^ Raw expression or type.</span></span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245805"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-228"></span><span id="toLambdaPi"><span class="annot"><span class="annottext">toLambdaPi :: forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var hs-var">toLambdaPi</span></a></span></span><span> </span><span id="local-6989586621679246569"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246570"><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-229"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Var"><span class="hs-identifier hs-type">Raw.Var</span></a></span><span> </span><span id="local-6989586621679246572"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246572"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246573"><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246573"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">VarIdent -&gt; Map VarIdent (Name n) -&gt; Maybe (Name n)
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246573"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-231"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679246575"><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246575"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name n -&gt; LambdaPi n
forall (n :: S) (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *).
Name n -&gt; AST binder sig n
</span><span class="hs-identifier hs-var">Var</span></span><span> </span><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246575"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-232"></span><span>      </span><span class="annot"><span class="annottext">Maybe (Name n)
</span><span class="hs-identifier hs-var">Nothing</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; LambdaPi n
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unbound variable: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">VarIdent -&gt; String
forall a. Print a =&gt; a -&gt; String
</span><a href="Language.LambdaPi.Syntax.Print.html#printTree"><span class="hs-identifier hs-var">Raw.printTree</span></a></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246573"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#App"><span class="hs-identifier hs-type">Raw.App</span></a></span><span> </span><span id="local-6989586621679246578"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246578"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246579"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246579"><span class="hs-identifier hs-var">fun</span></a></span></span><span> </span><span id="local-6989586621679246580"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246580"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-235"></span><span>    </span><span class="annot"><span class="annottext">LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#App"><span class="hs-identifier hs-var">App</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246579"><span class="hs-identifier hs-var">fun</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246580"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span>
</span><span id="line-237"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Lam"><span class="hs-identifier hs-type">Raw.Lam</span></a></span><span> </span><span id="local-6989586621679246582"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246582"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246583"><span class="annot"><span class="annottext">Pattern
</span><a href="#local-6989586621679246583"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621679246584"><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246584"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; Map VarIdent (Name n) -&gt; Pattern -&gt; ScopedTerm -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n
-&gt; Map VarIdent (Name n) -&gt; Pattern -&gt; ScopedTerm -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiLam"><span class="hs-identifier hs-var">toLambdaPiLam</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern
</span><a href="#local-6989586621679246583"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246584"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-238"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Pi"><span class="hs-identifier hs-type">Raw.Pi</span></a></span><span> </span><span id="local-6989586621679246586"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246586"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246587"><span class="annot"><span class="annottext">Pattern
</span><a href="#local-6989586621679246587"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621679246588"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246588"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679246589"><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246589"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; Map VarIdent (Name n)
-&gt; Pattern
-&gt; Term
-&gt; ScopedTerm
-&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n
-&gt; Map VarIdent (Name n)
-&gt; Pattern
-&gt; Term
-&gt; ScopedTerm
-&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiPi"><span class="hs-identifier hs-var">toLambdaPiPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern
</span><a href="#local-6989586621679246587"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246588"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246589"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-239"></span><span>
</span><span id="line-240"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Pair"><span class="hs-identifier hs-type">Raw.Pair</span></a></span><span> </span><span id="local-6989586621679246591"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246591"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246592"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246592"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246593"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246593"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Pair"><span class="hs-identifier hs-var">Pair</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246592"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246593"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-241"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#First"><span class="hs-identifier hs-type">Raw.First</span></a></span><span> </span><span id="local-6989586621679246595"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246595"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246596"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246596"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n -&gt; LambdaPi n
forall (n :: S). LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#First"><span class="hs-identifier hs-var">First</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246596"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Second"><span class="hs-identifier hs-type">Raw.Second</span></a></span><span> </span><span id="local-6989586621679246598"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246598"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246599"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246599"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n -&gt; LambdaPi n
forall (n :: S). LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Second"><span class="hs-identifier hs-var">Second</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246599"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-243"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Product"><span class="hs-identifier hs-type">Raw.Product</span></a></span><span> </span><span id="local-6989586621679246601"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246601"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246602"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246602"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246603"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246603"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
forall (n :: S). LambdaPi n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Product"><span class="hs-identifier hs-var">Product</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246602"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246569"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246570"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246603"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-244"></span><span>
</span><span id="line-245"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Universe"><span class="hs-identifier hs-type">Raw.Universe</span></a></span><span> </span><span id="local-6989586621679246605"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246605"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LambdaPi n
forall (n :: S). LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Universe"><span class="hs-identifier hs-var">Universe</span></a></span><span>
</span><span id="line-246"></span><span>
</span><span id="line-247"></span><span class="annot"><span class="hs-comment">-- | Convert a raw expression into a /closed/ scope-safe \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-248"></span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiClosed"><span class="hs-identifier hs-type">toLambdaPiClosed</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Term"><span class="hs-identifier hs-type">Raw.Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span>
</span><span id="line-249"></span><span id="toLambdaPiClosed"><span class="annot"><span class="annottext">toLambdaPiClosed :: Term -&gt; LambdaPi 'VoidS
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPiClosed"><span class="hs-identifier hs-var hs-var">toLambdaPiClosed</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
-&gt; Map VarIdent (Name 'VoidS) -&gt; Term -&gt; LambdaPi 'VoidS
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
</span><span class="hs-identifier hs-var">Foil.emptyScope</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name 'VoidS)
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span class="annot"><span class="hs-comment">-- | Convert back from a scope-safe \(\lambda\Pi\)-term into a raw expression or type.</span></span><span>
</span><span id="line-252"></span><span id="local-6989586621679245829"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-type">fromLambdaPi</span></a></span><span>
</span><span id="line-253"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span class="hs-special">]</span><span>               </span><span class="annot"><span class="hs-comment">-- ^ Stream of fresh raw identifiers.</span></span><span>
</span><span id="line-254"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.NameMap</span></span><span> </span><span class="annot"><a href="#local-6989586621679245829"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ A /total/ map for all names in scope @n@.</span></span><span>
</span><span id="line-255"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245829"><span class="hs-identifier hs-type">n</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ A scope-safe \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-256"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Term"><span class="hs-identifier hs-type">Raw.Term</span></a></span></span><span>
</span><span id="line-257"></span><span id="fromLambdaPi"><span class="annot"><span class="annottext">fromLambdaPi :: forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var hs-var">fromLambdaPi</span></a></span></span><span> </span><span id="local-6989586621679246608"><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span></span><span> </span><span id="local-6989586621679246609"><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-258"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Var</span></span><span> </span><span id="local-6989586621679246610"><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246610"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; VarIdent -&gt; Term
forall a. a -&gt; VarIdent -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Var"><span class="hs-identifier hs-var">Raw.Var</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name n -&gt; NameMap n VarIdent -&gt; VarIdent
forall (n :: S) a. Name n -&gt; NameMap n a -&gt; a
</span><span class="hs-identifier hs-var">Foil.lookupName</span></span><span> </span><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246610"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-259"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679246613"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246613"><span class="hs-identifier hs-var">fun</span></a></span></span><span> </span><span id="local-6989586621679246614"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246614"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#App"><span class="hs-identifier hs-var">Raw.App</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246613"><span class="hs-identifier hs-var">fun</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246614"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Lam"><span class="hs-identifier hs-type">Lam</span></a></span><span> </span><span id="local-6989586621679246617"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246617"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246618"><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246618"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-261"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-262"></span><span>      </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Term
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;not enough fresh variables&quot;</span></span><span>
</span><span id="line-263"></span><span>      </span><span id="local-6989586621679246619"><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246619"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679246620"><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246620"><span class="hs-identifier hs-var">freshVars'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-264"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246621"><span class="annot"><span class="annottext">env' :: NameMap l VarIdent
</span><a href="#local-6989586621679246621"><span class="hs-identifier hs-var hs-var">env'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l
-&gt; VarIdent -&gt; NameMap n VarIdent -&gt; NameMap l VarIdent
forall (n :: S) (l :: S) a.
NameBinder n l -&gt; a -&gt; NameMap n a -&gt; NameMap l a
</span><span class="hs-identifier hs-var">Foil.addNameBinder</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246617"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246619"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span>
</span><span id="line-265"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Pattern -&gt; ScopedTerm -&gt; Term
forall a. a -&gt; Pattern' a -&gt; ScopedTerm' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Lam"><span class="hs-identifier hs-var">Raw.Lam</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BNFC'Position -&gt; VarIdent -&gt; Pattern
forall a. a -&gt; VarIdent -&gt; Pattern' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#PatternVar"><span class="hs-identifier hs-var">Raw.PatternVar</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246619"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; ScopedTerm
forall a. a -&gt; Term' a -&gt; ScopedTerm' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-var">Raw.AScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap l VarIdent -&gt; LambdaPi l -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246620"><span class="hs-identifier hs-var">freshVars'</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap l VarIdent
</span><a href="#local-6989586621679246621"><span class="hs-identifier hs-var">env'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246618"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pi"><span class="hs-identifier hs-type">Pi</span></a></span><span> </span><span id="local-6989586621679246625"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246625"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246626"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246626"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679246627"><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246627"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-267"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-268"></span><span>      </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Term
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;not enough fresh variables&quot;</span></span><span>
</span><span id="line-269"></span><span>      </span><span id="local-6989586621679246628"><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246628"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679246629"><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246629"><span class="hs-identifier hs-var">freshVars'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-270"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246630"><span class="annot"><span class="annottext">env' :: NameMap l VarIdent
</span><a href="#local-6989586621679246630"><span class="hs-identifier hs-var hs-var">env'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l
-&gt; VarIdent -&gt; NameMap n VarIdent -&gt; NameMap l VarIdent
forall (n :: S) (l :: S) a.
NameBinder n l -&gt; a -&gt; NameMap n a -&gt; NameMap l a
</span><span class="hs-identifier hs-var">Foil.addNameBinder</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246625"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246628"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span>
</span><span id="line-271"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Pattern -&gt; Term -&gt; ScopedTerm -&gt; Term
forall a. a -&gt; Pattern' a -&gt; Term' a -&gt; ScopedTerm' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Pi"><span class="hs-identifier hs-var">Raw.Pi</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BNFC'Position -&gt; VarIdent -&gt; Pattern
forall a. a -&gt; VarIdent -&gt; Pattern' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#PatternVar"><span class="hs-identifier hs-var">Raw.PatternVar</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246628"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246626"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; ScopedTerm
forall a. a -&gt; Term' a -&gt; ScopedTerm' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-var">Raw.AScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap l VarIdent -&gt; LambdaPi l -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246629"><span class="hs-identifier hs-var">freshVars'</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap l VarIdent
</span><a href="#local-6989586621679246630"><span class="hs-identifier hs-var">env'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246627"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-272"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pair"><span class="hs-identifier hs-type">Pair</span></a></span><span> </span><span id="local-6989586621679246631"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246631"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246632"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246632"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Pair"><span class="hs-identifier hs-var">Raw.Pair</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246631"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246632"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#First"><span class="hs-identifier hs-type">First</span></a></span><span> </span><span id="local-6989586621679246633"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246633"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#First"><span class="hs-identifier hs-var">Raw.First</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246633"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-274"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Second"><span class="hs-identifier hs-type">Second</span></a></span><span> </span><span id="local-6989586621679246634"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246634"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Second"><span class="hs-identifier hs-var">Raw.Second</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246634"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-275"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Product"><span class="hs-identifier hs-type">Product</span></a></span><span> </span><span id="local-6989586621679246635"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246635"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246636"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246636"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Product"><span class="hs-identifier hs-var">Raw.Product</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246635"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
forall (n :: S).
[VarIdent] -&gt; NameMap n VarIdent -&gt; LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi"><span class="hs-identifier hs-var">fromLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">[VarIdent]
</span><a href="#local-6989586621679246608"><span class="hs-identifier hs-var">freshVars</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n VarIdent
</span><a href="#local-6989586621679246609"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246636"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-276"></span><span>  </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Universe"><span class="hs-identifier hs-var">Universe</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term
forall a. a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Universe"><span class="hs-identifier hs-var">Raw.Universe</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-277"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-278"></span><span>    </span><span id="local-6989586621679246611"><span class="annot"><span class="annottext">loc :: a
</span><a href="#local-6989586621679246611"><span class="hs-identifier hs-var hs-var">loc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; a
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;no location info available when converting from an AST&quot;</span></span><span>
</span><span id="line-279"></span><span>
</span><span id="line-280"></span><span class="hs-comment">-- | Convert back from a scope-safe \(\lambda\Pi\)-term into a raw expression or type.</span><span>
</span><span id="line-281"></span><span class="hs-comment">--</span><span>
</span><span id="line-282"></span><span class="hs-comment">-- In contrast to 'fromLambdaPi', this function uses the raw foil identifiers (integers)</span><span>
</span><span id="line-283"></span><span class="hs-comment">-- to generate names for the variables. This makes them transparent when printing.</span><span>
</span><span id="line-284"></span><span id="local-6989586621679245845"><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-type">fromLambdaPi'</span></a></span><span>
</span><span id="line-285"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245845"><span class="hs-identifier hs-type">n</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ A scope-safe \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-286"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Term"><span class="hs-identifier hs-type">Raw.Term</span></a></span></span><span>
</span><span id="line-287"></span><span id="fromLambdaPi%27"><span class="annot"><span class="annottext">fromLambdaPi' :: forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var hs-var">fromLambdaPi'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-288"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Var</span></span><span> </span><span id="local-6989586621679246640"><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246640"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; VarIdent -&gt; Term
forall a. a -&gt; VarIdent -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Var"><span class="hs-identifier hs-var">Raw.Var</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name n -&gt; VarIdent
forall {l :: S}. Name l -&gt; VarIdent
</span><a href="#local-6989586621679246642"><span class="hs-identifier hs-var">ppName</span></a></span><span> </span><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246640"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-289"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679246643"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246643"><span class="hs-identifier hs-var">fun</span></a></span></span><span> </span><span id="local-6989586621679246644"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246644"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#App"><span class="hs-identifier hs-var">Raw.App</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246643"><span class="hs-identifier hs-var">fun</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246644"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-290"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Lam"><span class="hs-identifier hs-type">Lam</span></a></span><span> </span><span id="local-6989586621679246645"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246645"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246646"><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246646"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-291"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246647"><span class="annot"><span class="annottext">x :: VarIdent
</span><a href="#local-6989586621679246647"><span class="hs-identifier hs-var hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name l -&gt; VarIdent
forall {l :: S}. Name l -&gt; VarIdent
</span><a href="#local-6989586621679246642"><span class="hs-identifier hs-var">ppName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinder n l -&gt; Name l
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246645"><span class="hs-identifier hs-var">binder</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-292"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Pattern -&gt; ScopedTerm -&gt; Term
forall a. a -&gt; Pattern' a -&gt; ScopedTerm' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Lam"><span class="hs-identifier hs-var">Raw.Lam</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BNFC'Position -&gt; VarIdent -&gt; Pattern
forall a. a -&gt; VarIdent -&gt; Pattern' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#PatternVar"><span class="hs-identifier hs-var">Raw.PatternVar</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246647"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; ScopedTerm
forall a. a -&gt; Term' a -&gt; ScopedTerm' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-var">Raw.AScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi l -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246646"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-293"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pi"><span class="hs-identifier hs-type">Pi</span></a></span><span> </span><span id="local-6989586621679246648"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246648"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246649"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246649"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679246650"><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246650"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-294"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246651"><span class="annot"><span class="annottext">x :: VarIdent
</span><a href="#local-6989586621679246651"><span class="hs-identifier hs-var hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name l -&gt; VarIdent
forall {l :: S}. Name l -&gt; VarIdent
</span><a href="#local-6989586621679246642"><span class="hs-identifier hs-var">ppName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinder n l -&gt; Name l
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246648"><span class="hs-identifier hs-var">binder</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-295"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Pattern -&gt; Term -&gt; ScopedTerm -&gt; Term
forall a. a -&gt; Pattern' a -&gt; Term' a -&gt; ScopedTerm' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Pi"><span class="hs-identifier hs-var">Raw.Pi</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BNFC'Position -&gt; VarIdent -&gt; Pattern
forall a. a -&gt; VarIdent -&gt; Pattern' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#PatternVar"><span class="hs-identifier hs-var">Raw.PatternVar</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246651"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246649"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; ScopedTerm
forall a. a -&gt; Term' a -&gt; ScopedTerm' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-var">Raw.AScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi l -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi l
</span><a href="#local-6989586621679246650"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-296"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Pair"><span class="hs-identifier hs-type">Pair</span></a></span><span> </span><span id="local-6989586621679246652"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246652"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246653"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246653"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Pair"><span class="hs-identifier hs-var">Raw.Pair</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246652"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246653"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-297"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#First"><span class="hs-identifier hs-type">First</span></a></span><span> </span><span id="local-6989586621679246654"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246654"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#First"><span class="hs-identifier hs-var">Raw.First</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246654"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-298"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Second"><span class="hs-identifier hs-type">Second</span></a></span><span> </span><span id="local-6989586621679246655"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246655"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Second"><span class="hs-identifier hs-var">Raw.Second</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246655"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-299"></span><span>  </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#Product"><span class="hs-identifier hs-type">Product</span></a></span><span> </span><span id="local-6989586621679246656"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246656"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679246657"><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246657"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term -&gt; Term -&gt; Term
forall a. a -&gt; Term' a -&gt; Term' a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Product"><span class="hs-identifier hs-var">Raw.Product</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246656"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LambdaPi n -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span> </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="#local-6989586621679246657"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-300"></span><span>  </span><span class="annot"><span class="annottext">LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#Universe"><span class="hs-identifier hs-var">Universe</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">BNFC'Position -&gt; Term
forall a. a -&gt; Term' a
</span><a href="Language.LambdaPi.Syntax.Abs.html#Universe"><span class="hs-identifier hs-var">Raw.Universe</span></a></span><span> </span><span class="annot"><span class="annottext">BNFC'Position
forall {a}. a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var">loc</span></a></span><span>
</span><span id="line-301"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-302"></span><span>    </span><span id="local-6989586621679246641"><span class="annot"><span class="annottext">loc :: a
</span><a href="#local-6989586621679246641"><span class="hs-identifier hs-var hs-var">loc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; a
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;no location info available when converting from an AST&quot;</span></span><span>
</span><span id="line-303"></span><span>    </span><span id="local-6989586621679246642"><span class="annot"><span class="annottext">ppName :: Name l -&gt; VarIdent
</span><a href="#local-6989586621679246642"><span class="hs-identifier hs-var hs-var">ppName</span></a></span></span><span> </span><span id="local-6989586621679246662"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679246662"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; VarIdent
</span><a href="Language.LambdaPi.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-var">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;x&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name l -&gt; Int
forall (l :: S). Name l -&gt; Int
</span><span class="hs-identifier hs-var">Foil.nameId</span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679246662"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span class="annot"><span class="hs-comment">-- | Pretty-print a /closed/ \(\lambda\Pi\)-term.</span></span><span>
</span><span id="line-306"></span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#ppLambdaPi"><span class="hs-identifier hs-type">ppLambdaPi</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#LambdaPi"><span class="hs-identifier hs-type">LambdaPi</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-307"></span><span id="ppLambdaPi"><span class="annot"><span class="annottext">ppLambdaPi :: LambdaPi 'VoidS -&gt; String
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#ppLambdaPi"><span class="hs-identifier hs-var hs-var">ppLambdaPi</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; String
forall a. Print a =&gt; a -&gt; String
</span><a href="Language.LambdaPi.Syntax.Print.html#printTree"><span class="hs-identifier hs-var">Raw.printTree</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; String)
-&gt; (LambdaPi 'VoidS -&gt; Term) -&gt; LambdaPi 'VoidS -&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">LambdaPi 'VoidS -&gt; Term
forall (n :: S). LambdaPi n -&gt; Term
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#fromLambdaPi%27"><span class="hs-identifier hs-var">fromLambdaPi'</span></a></span><span>
</span><span id="line-308"></span><span>
</span><span id="line-309"></span><span class="annot"><span class="hs-comment">-- | Interpret a \(\lambda\Pi\) command.</span></span><span>
</span><span id="line-310"></span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#interpretCommand"><span class="hs-identifier hs-type">interpretCommand</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Command"><span class="hs-identifier hs-type">Raw.Command</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-311"></span><span id="interpretCommand"><span class="annot"><span class="annottext">interpretCommand :: Command -&gt; IO ()
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#interpretCommand"><span class="hs-identifier hs-var hs-var">interpretCommand</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#CommandCompute"><span class="hs-identifier hs-type">Raw.CommandCompute</span></a></span><span> </span><span id="local-6989586621679246668"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246668"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246669"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246669"><span class="hs-identifier hs-var">term</span></a></span></span><span> </span><span id="local-6989586621679246670"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246670"><span class="hs-identifier hs-var">_type</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-312"></span><span>      </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;  &#8614; &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">LambdaPi 'VoidS -&gt; String
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#ppLambdaPi"><span class="hs-identifier hs-var">ppLambdaPi</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope 'VoidS -&gt; LambdaPi 'VoidS -&gt; LambdaPi 'VoidS
forall (n :: S). Distinct n =&gt; Scope n -&gt; LambdaPi n -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
</span><span class="hs-identifier hs-var">Foil.emptyScope</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope 'VoidS
-&gt; Map VarIdent (Name 'VoidS) -&gt; Term -&gt; LambdaPi 'VoidS
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; LambdaPi n
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#toLambdaPi"><span class="hs-identifier hs-var">toLambdaPi</span></a></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
</span><span class="hs-identifier hs-var">Foil.emptyScope</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name 'VoidS)
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246669"><span class="hs-identifier hs-var">term</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-313"></span><span class="hs-comment">-- #TODO: add typeCheck</span><span>
</span><span id="line-314"></span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#interpretCommand"><span class="hs-identifier hs-var">interpretCommand</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#CommandCheck"><span class="hs-identifier hs-type">Raw.CommandCheck</span></a></span><span> </span><span id="local-6989586621679246673"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246673"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246674"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246674"><span class="hs-identifier hs-var">_term</span></a></span></span><span> </span><span id="local-6989586621679246675"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246675"><span class="hs-identifier hs-var">_type</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;check is not yet implemented&quot;</span></span><span>
</span><span id="line-315"></span><span>
</span><span id="line-316"></span><span class="annot"><span class="hs-comment">-- | Interpret a \(\lambda\Pi\) program.</span></span><span>
</span><span id="line-317"></span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#interpretProgram"><span class="hs-identifier hs-type">interpretProgram</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#Program"><span class="hs-identifier hs-type">Raw.Program</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-318"></span><span id="interpretProgram"><span class="annot"><span class="annottext">interpretProgram :: Program -&gt; IO ()
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#interpretProgram"><span class="hs-identifier hs-var hs-var">interpretProgram</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.LambdaPi.Syntax.Abs.html#AProgram"><span class="hs-identifier hs-type">Raw.AProgram</span></a></span><span> </span><span id="local-6989586621679246678"><span class="annot"><span class="annottext">BNFC'Position
</span><a href="#local-6989586621679246678"><span class="hs-identifier hs-var">_loc</span></a></span></span><span> </span><span id="local-6989586621679246679"><span class="annot"><span class="annottext">[Command]
</span><a href="#local-6989586621679246679"><span class="hs-identifier hs-var">typedTerms</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Command -&gt; IO ()) -&gt; [Command] -&gt; IO ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="annot"><span class="annottext">Command -&gt; IO ()
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#interpretCommand"><span class="hs-identifier hs-var">interpretCommand</span></a></span><span> </span><span class="annot"><span class="annottext">[Command]
</span><a href="#local-6989586621679246679"><span class="hs-identifier hs-var">typedTerms</span></a></span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="annot"><span class="hs-comment">-- | A \(\lambda\Pi\) interpreter implemented via the free foil.</span></span><span>
</span><span id="line-321"></span><span class="annot"><a href="Language.LambdaPi.Impl.FreeFoil.html#defaultMain"><span class="hs-identifier hs-type">defaultMain</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-322"></span><span id="defaultMain"><span class="annot"><span class="annottext">defaultMain :: IO ()
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#defaultMain"><span class="hs-identifier hs-var hs-var">defaultMain</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-323"></span><span>  </span><span id="local-6989586621679246681"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246681"><span class="hs-identifier hs-var">input</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">IO String
</span><span class="hs-identifier hs-var">getContents</span></span><span>
</span><span id="line-324"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Token] -&gt; Err Program
</span><a href="Language.LambdaPi.Syntax.Par.html#pProgram"><span class="hs-identifier hs-var">Raw.pProgram</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; [Token] -&gt; [Token]
</span><a href="Language.LambdaPi.Syntax.Layout.html#resolveLayout"><span class="hs-identifier hs-var">Raw.resolveLayout</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; [Token]
</span><a href="Language.LambdaPi.Syntax.Lex.html#tokens"><span class="hs-identifier hs-var">Raw.tokens</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246681"><span class="hs-identifier hs-var">input</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-325"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679246685"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246685"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-326"></span><span>      </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246685"><span class="hs-identifier hs-var">err</span></a></span><span>
</span><span id="line-327"></span><span>      </span><span class="annot"><span class="annottext">IO ()
forall a. IO a
</span><span class="hs-identifier hs-var">exitFailure</span></span><span>
</span><span id="line-328"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679246686"><span class="annot"><span class="annottext">Program
</span><a href="#local-6989586621679246686"><span class="hs-identifier hs-var">program</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Program -&gt; IO ()
</span><a href="Language.LambdaPi.Impl.FreeFoil.html#interpretProgram"><span class="hs-identifier hs-var">interpretProgram</span></a></span><span> </span><span class="annot"><span class="annottext">Program
</span><a href="#local-6989586621679246686"><span class="hs-identifier hs-var">program</span></a></span><span>
</span><span id="line-329"></span></pre></body></html>